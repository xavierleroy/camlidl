/* Helper functions for stub code generated by camlidl */

#include <stddef.h>
#include <caml/mlvalues.h>

/* Functions for allocating in the Caml heap */

#if !defined(CAMLVERSION) || CAMLVERSION >= 201
#define camlidl_alloc alloc
#define camlidl_alloc_small alloc_small
#else
value camlidl_alloc(mlsize_t size, tag_t tag);
#define camlidl_alloc_small alloc
#endif

/* Helper functions for conversion */

value camlidl_find_enum(int n, int *flags, int nflags, char *errmsg);
value camlidl_alloc_flag_list (int n, int *flags, int nflags);
mlsize_t camlidl_ptrarray_size(void ** array);

/* Malloc-like allocation with en masse deallocation */

struct camlidl_block_list {
  void * block;
  struct camlidl_block_list * next;
};

typedef struct camlidl_block_list * camlidl_arena;

void * camlidl_malloc(size_t sz, camlidl_arena * arena);
void camlidl_free(camlidl_arena arena);

/* Helper functions for handling COM interfaces */

#ifndef _WIN32
#define interface struct
typedef struct { unsigned char data[16]; } IID;
typedef int HRESULT;
typedef unsigned long ULONG;
#endif

#ifdef __GNUC__
#define DECLARE_VTBL_PADDING void * padding; void * constr;
#define VTBL_PADDING 0, 0,
#endif

value camlidl_lookup_method(char * name);

void * camlidl_unpack_interface(value vintf);
value camlidl_pack_interface(void * intf);

struct camlidl_intf {
  void * vtbl;
  value caml_object;
  int refcount;
  IID * iid;
};

value camlidl_make_interface(void * vtbl, value caml_object, IID * iid);

/* Basic methods (QueryInterface, AddRef, Release) for COM objects
   encapsulating a Caml object */

HRESULT camlidl_QueryInterface(struct camlidl_intf * this, IID * iid,
                               void ** object);
ULONG camlidl_AddRef(struct camlidl_intf * this);
ULONG camlidl_Release(struct camlidl_intf * this);

/* TODO: class factories? */

/* Should be in mlvalues.h? */
#define Lookup(obj, lab) \
  Field (Field (Field (obj, 0), ((lab) >> 16) / sizeof (value)), \
         ((lab) / sizeof (value)) & 0xFF)
