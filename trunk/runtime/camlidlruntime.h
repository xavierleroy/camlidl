/* Helper functions for stub code generated by camlidl */

#include <stddef.h>
#include <caml/mlvalues.h>

/* Functions for allocating in the Caml heap */

#if !defined(CAMLVERSION) || CAMLVERSION >= 201
#define camlidl_alloc alloc
#define camlidl_alloc_small alloc_small
#else
value camlidl_alloc(mlsize_t size, tag_t tag);
#define camlidl_alloc_small alloc
#endif

/* Helper functions for conversion */

value camlidl_find_enum(int n, int *flags, int nflags, char *errmsg);
value camlidl_alloc_flag_list (int n, int *flags, int nflags);
mlsize_t camlidl_ptrarray_size(void ** array);

/* Malloc-like allocation with en masse deallocation */

struct camlidl_block_list {
  void * block;
  struct camlidl_block_list * next;
};

struct camlidl_ctx_struct {
  int flags;
  struct camlidl_block_list * head;
};

#define CAMLIDL_TRANSIENT 1
#define CAMLIDL_ADDREF 2

typedef struct camlidl_ctx_struct * camlidl_ctx;

void * camlidl_malloc(size_t sz, camlidl_ctx ctx);
void camlidl_free(camlidl_ctx ctx);
char * camlidl_malloc_string(value mlstring, camlidl_ctx ctx);

/* Helper functions for handling COM interfaces */

#ifdef _WIN32
#include <objbase.h>
#else
#define interface struct
typedef struct {
  unsigned int Data1;
  unsigned short Data2, Data3;
  unsigned char Data4[8];
} GUID, IID;
typedef IID * REFIID;
typedef int HRESULT;
typedef unsigned long ULONG;
#define SetErrorInfo(x,y)
#define STDMETHODCALLTYPE
#endif

#if defined(_WIN32)
#define DECLARE_VTBL_PADDING
#define VTBL_PADDING
#elif defined(__GNUC__)
#define DECLARE_VTBL_PADDING void * padding; void * constr;
#define VTBL_PADDING 0, 0,
#endif

value camlidl_lookup_method(char * name);

void * camlidl_unpack_interface(value vintf, camlidl_ctx ctx);
value camlidl_pack_interface(void * intf, camlidl_ctx ctx);

struct camlidl_component;

struct camlidl_intf {
  void * vtbl;
  value caml_object;
  IID * iid;
  struct camlidl_component * comp;
};

struct camlidl_component {
  int numintfs;
  long refcount;
  struct camlidl_intf intf[1];
};

value camlidl_make_interface(void * vtbl, value caml_object, IID * iid);

/* Basic methods (QueryInterface, AddRef, Release) for COM objects
   encapsulating a Caml object */

HRESULT STDMETHODCALLTYPE
camlidl_QueryInterface(struct camlidl_intf * self, REFIID iid,
                       void ** object);
ULONG STDMETHODCALLTYPE
camlidl_AddRef(struct camlidl_intf * self);
ULONG STDMETHODCALLTYPE
camlidl_Release(struct camlidl_intf * self);

/* Lookup a method in a method suite */
/* (Should be in mlvalues.h?) */

#define Lookup(obj, lab) \
  Field (Field (Field (obj, 0), ((lab) >> 16) / sizeof (value)), \
         ((lab) / sizeof (value)) & 0xFF)

/* Raise an error */
void camlidl_error(HRESULT errcode, char * who, char * msg);

/* Handle HRESULTs */

void camlidl_check_hresult(HRESULT hr);
value camlidl_c2ml_hresult_bool(HRESULT hr);
void camlidl_ml2c_hresult_bool(value v, HRESULT * hr);
value camlidl_c2ml_hresult_int(HRESULT hr);
void camlidl_ml2c_hresult_int(value v, HRESULT * hr);

/* Handle uncaught exceptions in C-to-ML callbacks */

HRESULT camlidl_result_exception(char * methname, value exn_bucket);
void camlidl_uncaught_exception(char * methname, value exn_bucket);

