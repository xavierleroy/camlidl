{|
#include <stdio.h>
#include <rsa.h>
#include <crypto.h>
#include <x509.h>
#include <pem.h>
#include <ssl.h>

typedef SSL_CTX * ssl_ctx;
typedef SSL * ssl;
typedef SSL_SESSION * ssl_session;
typedef SSL_METHOD * ssl_method;
typedef X509 * x509;
typedef RSA * rsa;
typedef EVP_PKEY * evp_pkey;

typedef int file_descriptor;

#define ml2c_file_descriptor(v,c) (*(c) = Int_val(v))
|}

typedef [abstract] SSL_CTX * ssl_ctx;
typedef [abstract] SSL * ssl;
typedef [abstract] SSL_SESSION * ssl_session;
typedef [abstract] SSL_METHOD * ssl_method;
typedef [abstract] X509 * x509;
typedef [abstract] RSA * rsa;
typedef [abstract] EVP_PKEY * evp_pkey;

typedef [mltype("Unix.file_descriptor"),
         ml2c(ml2c_file_descriptor),
         c2ml(Val_int)]
        int file_descriptor;

// SSL_CTX_sessions(SSL_CTX *ctx) - the session-id hash table.

/* Session-id cache stats */
// SSL_CTX_sess_number -- pas envie de remonter lhash.h
// SSL_CTX_sess_connect
// SSL_CTX_sess_connect_good
// SSL_CTX_sess_accept
// SSL_CTX_sess_accept_good
// SSL_CTX_sess_hits
// SSL_CTX_sess_cb_hits
// SSL_CTX_sess_misses
// SSL_CTX_sess_timeouts

/* Session-id application notification callbacks */
// SSL_CTX_sess_set_new_cb -- pas de callbacks
// SSL_CTX_sess_get_new_cb
// SSL_CTX_sess_set_get_cb
// SSL_CTX_sess_get_get_cb

/* Session-id cache operation mode */

enum ssl_sess_cache { SSL_SESS_CACHE_CLIENT, SSL_SESS_CACHE_SERVER };

void SSL_CTX_set_session_cache_mode(ssl_ctx ctx, [set] enum ssl_sess_cache c);
[set] (enum ssl_sess_cache) SSL_CTX_get_session_cache_mode(ssl_ctx ctx);

/* Set default timeout values to use. */
void SSL_CTX_set_timeout(ssl_ctx ctx, long timeout);
long SSL_CTX_get_timeout(ssl_ctx ctx);

/* Global  SSL initalisation informational callback */
// SSL_CTX_set_info_callback
// SSL_CTX_get_info_callback
// SSL_set_info_callback
// SSL_get_info_callback

/* If the SSL_accept/SSL_connect returned with -1, these indicate when
 * we should re-call */

enum ssl_rwstate { SSL_NOTHING, SSL_WRITING, SSL_READING, SSL_X509_LOOKUP };

(enum ssl_rwstate) SSL_want(ssl s);
// SSL_want_nothing // special case of ssl_rwstate
// SSL_want_read
// SSL_want_write
// SSL_want_x509_lookup

/* Where we are in SSL initalisation, used in non-blocking, perhaps
 * have a look at ssl/bio_ssl.c */
// SSL_state
boolean SSL_is_init_finished(ssl s);
boolean SSL_in_init(ssl s);
boolean SSL_in_connect_init(ssl s);
boolean SSL_in_accept_init(ssl s);

/* Used to set the 'inital' state so SSL_in_connect_init and SSL_in_accept_init
 * can be used to work out which function to call. */
void SSL_set_connect_state(ssl s);
void SSL_set_accept_state(ssl s);

/* Where to look for certificates for authentication */
int SSL_CTX_set_default_verify_paths(ssl_ctx ctx);
int SSL_CTX_load_verify_locations(ssl_ctx ctx, [string] char * CAfile,
                                  [string] char * CApath);

/* get info from an established connection */
ssl_session SSL_get_session(ssl s);
x509 SSL_get_certificate(ssl s);
ssl_ctx SSL_get_SSL_CTX(ssl s);

ssl_ctx SSL_CTX_new(ssl_method meth);
void SSL_CTX_free(ssl_ctx ctx);  // finalisation?
ssl SSL_new(ssl_ctx ctx);
void SSL_clear(ssl s);
void SSL_free(ssl s); // finalisation?
int SSL_CTX_set_ssl_version(ssl_ctx ctx, ssl_method meth);
ssl_method SSLv2_method(void);
ssl_method SSLv2_server_method(void);
ssl_method SSLv2_client_method(void);
ssl_method SSLv3_method(void);
ssl_method SSLv3_server_method(void);
ssl_method SSLv3_client_method(void);
ssl_method SSLv23_method(void);
ssl_method SSLv23_server_method(void);
ssl_method SSLv23_client_method(void);

int SSL_CTX_set_cipher_list(ssl_ctx ctx, [string] char * str);
[string] char * SSL_get_cipher(ssl s); // string, really?
int SSL_set_cipher_list(ssl s, [string] char * str); // string, really?
[string] char * SSL_get_cipher_list(ssl s, int n); // string, really?
[string] char * SSL_get_shared_ciphers(ssl s) // string, really?
        {| { char buf[4096];
             _res = SSL_get_shared_ciphers(s, buf, sizeof(buf));
             if (_res == NULL) failwith("SSL_get_shared_ciphers"); } |};

int SSL_accept(ssl s); // error code? file descriptor? both?
int SSL_connect(ssl s); // error code?
int SSL_read(ssl s, [string] char * buf, long ofs, int num)
	{| if (ofs < 0 || ofs + num > string_length(_v_buf))
             invalid_argument("SSL_read");
           _res = SSL_read(s, buf + ofs, num); |};
int SSL_write(ssl s, [string] char * buf, long ofs, int num)
	{| if (ofs < 0 || ofs + num > string_length(_v_buf))
             invalid_argument("SSL_write");
           _res = SSL_write(s, buf + ofs, num); |};

// SSL_debug -- pas dans ssl.h

boolean SSL_get_read_ahead(ssl s);
void SSL_set_read_ahead(ssl s, boolean yes);
// SSL_set_verify  -- il y a un callback

int SSL_pending(ssl s); // boolean?

boolean SSL_set_fd(ssl s, file_descriptor fd);
boolean SSL_set_rfd(ssl s, file_descriptor fd);
boolean SSL_set_wfd(ssl s, file_descriptor fd);
file_descriptor SSL_get_fd(ssl s);
// SSL_set_bio -- pas envie de remonter BIO
// SSL_get_rbio -- pas envie de remonter BIO
// SSL_get_wbio -- pas envie de remonter BIO

int SSL_use_RSAPrivateKey(ssl s, rsa r);
int SSL_use_RSAPrivateKey_ASN1(ssl s,
                               [string,size_is(len)] unsigned char * d,
                               long len);
enum ssl_filetype { SSL_FILETYPE_ASN1, SSL_FILETYPE_PEM };
int SSL_use_RSAPrivateKey_file(ssl s, [string] char * file,
                               enum ssl_filetype type);
int SSL_use_PrivateKey(ssl s, evp_pkey k); // operations sur evp_pkey?
int SSL_use_PrivateKey_ASN1(int pk, ssl s,
                            [string,size_is(len)] unsigned char * d,
                            long len);
int SSL_use_PrivateKey_file(ssl s, [string] char * file,
                            enum ssl_filetype type);
int SSL_use_certificate(ssl s, x509 x);
int SSL_use_certificate_ASN1(ssl s,
                             long len,
                             [string,size_is(len)] unsigned char * d);
int SSL_use_certificate_file(ssl s, [string] char * file,
                             enum ssl_filetype type);

void ERR_load_SSL_strings(void);
void SSL_load_error_strings(void);

/* human readable version of the 'state' of the SSL connection. */
[string] char * SSL_state_string(ssl s);
[string] char * SSL_state_string_long(ssl s);

/* These 2 report what kind of IO operation the library was trying to
 * perform last.  Probably not very usefull. */
[string] char * SSL_rstate_string(ssl s);
[string] char * SSL_rstate_string_long(ssl s);

x509 SSL_get_peer_certificate(ssl s);

ssl_session SSL_SESSION_new(void);
// SSL_SESSION_print_fp -- utilise un FILE *
// SSL_SESSION_print -- utilise un BIO
void SSL_SESSION_free(ssl_session s); // finalisation?
// i2d_SSL_SESSION -- comprends pas le proto
// d2i_SSL_SESSION -- comprends pas le proto

long SSL_get_time(ssl_session s);
long SSL_set_time(ssl_session s, long t);
long SSL_get_timeout(ssl_session s);
long SSL_set_timeout(ssl_session s, long t);
void SSL_copy_session_id(ssl to, ssl from);
int SSL_set_session(ssl to, ssl_session session);
int SSL_CTX_add_session(ssl_ctx ctx, ssl_session c);
int SSL_CTX_remove_session(ssl_ctx ctx, ssl_session c);
void SSL_CTX_flush_sessions(ssl_ctx ctx, long tm);

// BIO_f_ssl -- utilise BIO

/* used to hold information as to why a certificate verification failed */
void SSL_set_verify_result(ssl s, int data);
int SSL_get_verify_result(ssl s);

/* can be used by the application to associate data with an SSL structure.
 * It needs to be 'free()ed' by the application */
// SSL_set_app_data -- probleme de gestion memoire
// SSL_get_app_data -- ditto

/* The following all set values that are kept in the SSL_CTX but
 * are used as the default values when an SSL session is created.
 * They are over writen by the relevent SSL_xxxx functions */

/* SSL_set_verify */
// void SSL_CTX_set_default_verify -- #if 0 dans ssl.h

/* This callback, if set, totaly overrides the normal SSLeay verification
 * functions and should return 1 on sucesss and 0 on failure */
// void SSL_CTX_set_cert_verify_callback -- no callbacks

/* The following are the same as the equivilent SSL_xxx functions.
 * Only one copy of this information is kept and if a particular
 * SSL structure has a local override, it is totally separate structure.
 */

int SSL_CTX_use_RSAPrivateKey(ssl_ctx ctx, rsa r);
int SSL_CTX_use_RSAPrivateKey_ASN1(ssl_ctx ctx,
                                   [string,size_is(len)] unsigned char * d,
                                   long len);
int SSL_CTX_use_RSAPrivateKey_file(ssl_ctx ctx, [string] char * file,
                               enum ssl_filetype type);
int SSL_CTX_use_PrivateKey(ssl_ctx ctx, evp_pkey k);
int SSL_CTX_use_PrivateKey_ASN1(int pk, ssl_ctx ctx,
                                [string,size_is(len)] unsigned char * d,
                                long len);
int SSL_CTX_use_PrivateKey_file(ssl_ctx ctx, [string] char * file,
                            enum ssl_filetype type);
int SSL_CTX_use_certificate(ssl_ctx ctx, x509 x);
int SSL_CTX_use_certificate_ASN1(ssl_ctx ctx,
                                 long len,
                                 [string,size_is(len)] unsigned char * d);
int SSL_CTX_use_certificate_file(ssl_ctx ctx, [string] char * file,
                             enum ssl_filetype type);

