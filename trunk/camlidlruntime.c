/* Helper functions for stub code generated by camlidl */

#include <string.h>
#include <caml/mlvalues.h>
#include <caml/memory.h>
#include <caml/alloc.h>
#include <caml/fail.h>
#include <caml/callback.h>
#include "camlidlruntime.h"

/* Helper functions for conversion */

value camlidl_find_enum(int n, int *flags, int nflags, char *errmsg)
{
  int i;

  for (i = 0; i < nflags; i++) {
    if (n == flags[i]) return Val_int(i);
  }
  invalid_argument(errmsg);
}

value camlidl_alloc_flag_list(int n, int *flags, int nflags)
{
  value l = Val_int(0);
  int i;

  Begin_root(l)
    for (i = nflags - 1; i >= 0; i--)
      if (n & flags[i]) {
        value v = alloc_small(2, 0);
        Field(v, 0) = Val_int(i);
        Field(v, 1) = l;
        l = v;
        n &= ~ flags[i];
      }
  End_roots();
  return l;
}

mlsize_t camlidl_ptrarray_size(void ** array)
{
  mlsize_t i;

  for (i = 0; array[i] != NULL; i++) /*nothing*/;
  return i;
}

/* Malloc-like allocation with en masse deallocation */

void * camlidl_malloc(size_t sz, camlidl_arena * arena)
{
  void * res = stat_alloc(sz);
  if (arena != NULL) {
    struct camlidl_block_list * l =
      stat_alloc(sizeof(struct camlidl_block_list));
    l->block = res;
    l->next = *arena;
    *arena = l;
  }
  return res;
}

void camlidl_free(camlidl_arena arena)
{
  camlidl_arena tmp;
  while (arena != NULL) {
    tmp = arena;
    arena = arena->next;
    stat_free(tmp);
  }
}

/* This function is for compatibility with OCaml 2.00 and earlier */

#if defined(CAMLVERSION) && CAMLVERSION < 201

value camlidl_alloc (mlsize_t wosize, tag_t tag)
{
  value result;
  mlsize_t i;

  Assert (wosize > 0);
  if (wosize <= Max_young_wosize){
    result = alloc (wosize, tag);
    if (tag < No_scan_tag){
      for (i = 0; i < wosize; i++) Field (result, i) = 0;
    }
  }else{
    result = alloc_shr (wosize, tag);
    if (tag < No_scan_tag) memset (Bp_val (result), 0, Bsize_wsize (wosize));
    result = check_urgent_gc (result);
  }
  return result;
}

#endif

/* Helper functions for handling COM interfaces */

value camlidl_lookup_method(char * name)
{
  static value * lookup_clos = NULL;

  if (lookup_clos == NULL) {
    lookup_clos = caml_named_value("Oo.new_method");
    if (lookup_clos == NULL) invalid_argument("Oo.new_method not registered");
  }
  return callback(*lookup_clos, copy_string(name));
}

#ifndef _WIN32
interface IUnknown;

struct IUnknownVtbl {
  HRESULT (*QueryInterface)(interface IUnknown * this,
                            IID * iid, void ** object);
  ULONG (*AddRef)(interface IUnknown * this);
  ULONG (*Release)(interface IUnknown * this);
};

interface IUnknown {
  struct IUnknownVtbl * lpVtbl;
};
#endif

static void camlidl_finalize_interface(value intf)
{
  interface IUnknown * i = (interface IUnknown *) Field(intf, 1);
  i->lpVtbl->Release(i);
}

value camlidl_pack_interface(void * intf)
{
  value res = alloc_final(2, camlidl_finalize_interface, 0, 1);
  Field(res, 1) = (value) intf;
  return res;
}

void * camlidl_unpack_interface(value vintf)
{
  return (void *) Field(vintf, 1);
}

void camlidl_make_interface(void * vtbl, value caml_object,
                            struct camlidl_intf * intf, IID * iid)
{
  intf->vtbl = vtbl;
  intf->caml_object = caml_object;
  intf->refcount = 1;
  intf->iid = iid;
  register_global_root(&(intf->caml_object));
}

/* Basic methods (QueryInterface, AddRef, Release) for COM objects
   encapsulating a Caml object */

#ifndef _WIN32
#define IsEqualIID(a,b) (memcmp(a, b, sizeof(IID)) == 0)
#define InterlockedIncrement(p) (++(*(p)))
#define InterlockedDecrement(p) (--(*(p)))
extern IID IID_IUnknown;
#define S_OK 0
#define E_NOINTERFACE (-1)
#endif

HRESULT camlidl_unknwn_IUnknown_QueryInterface_callback
          (struct camlidl_intf * this, IID * iid, void ** object)
{
  if (IsEqualIID(iid, this->iid) || IsEqualIID(this, &IID_IUnknown)) {
    *object = (void *) this;
    InterlockedIncrement(&(this->refcount));
    return S_OK;
  } else {
    *object = NULL;
    return E_NOINTERFACE;
  }
}
  
ULONG camlidl_unknwn_IUnknown_AddRef_callback(struct camlidl_intf * this)
{
  return InterlockedIncrement(&(this->refcount));
}

ULONG camlidl_unknwn_IUnknown_Release_callback(struct camlidl_intf * this)
{
  ULONG newrefcount = InterlockedDecrement(&(this->refcount));
  if (newrefcount == 0) {
    remove_global_root(&(this->caml_object));
    stat_free(this);
  }
  return newrefcount;
}
